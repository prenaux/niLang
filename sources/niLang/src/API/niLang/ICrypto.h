#pragma once
#ifndef __ICRYPTO_H_05BFBCD8_3E83_4730_840C_B7BEC964EA6A__
#define __ICRYPTO_H_05BFBCD8_3E83_4730_840C_B7BEC964EA6A__
// SPDX-FileCopyrightText: (c) 2022 The niLang Authors
// SPDX-License-Identifier: MIT
#include "Types.h"
#if niMinFeatures(15)
#include "IToString.h"

namespace ni {

struct iFile;

/** \addtogroup niLang
 * @{
 */

//! Max data returned by CryptoKDFCrypt
static const tU32 knCryptoKDFCryptMaxLen = 128;
//! Max data returned by CryptoKDFGenSalt*
static const tU32 knCryptoKDFSaltMaxLen = 128;

//! Crypto random number generator.
struct iCryptoRand : public iUnknown
{
  niDeclareInterfaceUUID(iCryptoRand,0x3215a36e,0x7a27,0x4cd2,0x99,0xe3,0xfe,0x95,0x5f,0x94,0xea,0x3a);

  virtual void __stdcall SetEntropyLength(tSize anEntropyLen) = 0;
  virtual void __stdcall SetReseedInterval(tInt anInterval) = 0;
  virtual void __stdcall SetPredictionResistance(tBool abPR) = 0;

  virtual tBool __stdcall Reseed(iFile* apFile, tSize anAddSize) = 0;
  virtual tBool __stdcall ReseedRaw(const tPtr apData, tSize anAddSize) = 0;

  virtual tBool __stdcall Update(iFile* apFile, tSize anAddSize) = 0;
  virtual tBool __stdcall UpdateRaw(const tPtr apAdd, tSize anAddSize) = 0;

  virtual tSize __stdcall RandFile(iFile* apFile, tSize anOutLen) = 0;
  virtual tSize __stdcall RandRaw(tPtr apOut, tSize anOutLen) = 0;
  virtual tI64  __stdcall RandInt() = 0;
  virtual tF64  __stdcall RandFloat() = 0;
  virtual tUUID __stdcall RandUUID() = 0;
};

niExportFunc(iCryptoRand*) GetCryptoRand();
niExportFunc(ni::iUnknown*) New_niLang_CryptoRand(const ni::Var&,const ni::Var&);

//! Generates a blowfish salt for CryptoKDFCrypt.
//! \param apRand is the random number generator that will be used to generate the salt data.
//! \param aRounds is the number of rounds that define the hashing complexity, should be in the range [4,31].
//! \param aaszOutput is the where the salt will be output, should be a buffer of knCryptoKDFSaltMaxLen bytes.
//! \return aaszOutput if successful else NULL.
//! \remark This method is designed to mirror exactly postgres's gen_salt('bf', aRounds) function.
//! \remark KDF stands for "Key Derivation Function" it is designed to be as
//!         slow as possible while still be tolerable. The goal is to prevent
//!         brute force attack of the hashes generated.
//! \remark This is a measure of how fast CryptoKDFCrypt will encrypt in
//!         function of the number of rounds (on P4 1.5Ghz, loop over 1000
//!         8chars pwd, details at
//!         https://www.postgresql.org/docs/8.3/static/pgcrypto.html):
//!         - 8 rounds, 28 hash/s,  246yrs for [a-z], 251322yrs for [A-Za-z0-9]
//!         - 7 rounds, 57 hash/s,  121yrs for [a-z], 123457yrs for [A-Za-z0-9]
//!         - 6 rounds, 112 hash/s,  62yrs for [a-z],  62831yrs for [A-Za-z0-9]
//!         - 5 rounds, 211 hash/s,  33yrs for [a-z],  33351yrs for [A-Za-z0-9]
niExportFunc(achar*) CryptoKDFGenSaltBlowfish(iCryptoRand* apRand, tU32 aRounds, achar* aaszOutput);

//! Calculates a bcrypt-style hash of password. When storing a new password,
//! you need to use CryptKDFGenSalt*() to generate a new salt value. To check a
//! password, pass the stored hash value as salt, and test whether the result
//! matches the stored value.
//! \param aaszKey is the password to encrypt.
//! \param aaszSalt is a salt as generated by CryptKDFGenSalt*.
//! \param aaszOutput is the where the encrypted result will be output, should be a buffer of knCryptoKDFCryptMaxLen bytes.
//! \return aaszOutput if successful else NULL.
//! \remark This method is designed to mirror exactly postgres's crypt(aKey, aSalt) function.
niExportFunc(achar*) CryptoKDFCrypt(const achar* aaszKey, const achar* aaszSalt, achar* aaszOutput);

//! Verify a RSA Signature. The payload's digest is computed as SHA256 and then RSA PCKS1 is used
//! to verify that the signature is valid.
niExportFunc(tBool) CryptoSigVerify(const char* signatureHex, const char* publicKeyPEM, const char* payload);

// Generate a keyed hash value using the HMAC method.
niExportFunc(ni::iFile*) CryptoHmacSignature(const char* aAlgo, ni::iFile* apOutput, ni::iFile* apPayload, ni::tSize aPayloadSize, const char* aSecret, ni::eRawToStringEncoding aSecretFormat);

struct iCrypto : public iUnknown {
  niDeclareInterfaceUUID(iCrypto,0xe3352941,0xf1e7,0x4e62,0x99,0x7d,0x4e,0xbb,0xf7,0xbd,0x47,0x7e);

  //! Compute the hash of the specified string. Does not include the end zero.
  virtual cString __stdcall Digest(const achar* aaszData, const achar* aType, eRawToStringEncoding aEncoding = eRawToStringEncoding_Hex) = 0;
  //! Compute the hash of the specified data.
  virtual cString __stdcall DigestRaw(const tPtr apData, tSize anSize, const achar* aType, eRawToStringEncoding aEncoding) = 0;
  //! Compute the hash of the specified data read from the specified file.
  virtual cString __stdcall DigestFile(iFile* apFile, tSize anSize, const achar* aType, eRawToStringEncoding aEncoding) = 0;

  //! Create a new random number generator.
  virtual iCryptoRand* __stdcall CreateRand() = 0;
  //! Get the default crypto random number generator.
  //! {Property}
  virtual iCryptoRand* __stdcall GetRand() = 0;

  //! Generate a salt for KDFCrypt. \see CryptoKDFGenSaltBlowfish
  //! \remark If apRand is NULL the default random number generator is used.
  virtual cString __stdcall KDFGenSaltBlowfish(iCryptoRand* apRand, tU32 aRounds) = 0;
  //! Calculates a crypt(3)-style hash of password. \see CryptoKDFCrypt
  virtual cString __stdcall KDFCrypt(const achar* aKey, const achar* aSalt) = 0;

  //! Verify a RSA signature for a specified payload.
  virtual tBool __stdcall SigVerify(const achar* signatureHex, const achar* publicKeyPEM, const achar* payload) = 0;

  //! Generate a keyed hash value using the HMAC method.
  virtual ni::iFile* __stdcall HmacSignature(const achar* aAlgo, ni::iFile* apOutput, ni::iFile* apPayload, ni::tSize aPayloadSize, const achar* aSecret, ni::eRawToStringEncoding aSecretFormat) = 0;
};

niExportFunc(iCrypto*) GetCrypto();
niExportFunc(ni::iUnknown*) New_niLang_Crypto(const ni::Var&,const ni::Var&);

//! Secure hash interface.
struct iCryptoHash : public iUnknown
{
  niDeclareInterfaceUUID(iCryptoHash,0xa299806d,0x929e,0x40e0,0xb6,0xb5,0xe8,0xaf,0x58,0x02,0x50,0xaf);

  //! Get the hash type.
  //! {Property}
  virtual const achar* __stdcall GetHashType() const = 0;
  //! Get the digest size.
  //! {Property}
  virtual tU32 __stdcall GetDigestSize() const = 0;

  //! Ends the calculation of the current digest and reset the states for
  //! a new calculation.
  virtual tBool __stdcall Restart() = 0;

  //! Adds data to the hash calculation, from the current file position for size bytes.
  virtual tBool __stdcall Update(iFile* apFile, tI64 aSize) = 0;
  //! Adds data to the hash calculation, specifing a data range.
  virtual tBool __stdcall UpdateBlock(iFile* apFile, tI64 aStart, tI64 aSize) = 0;
  //! Adds raw data to the hash calculation.
  //! {NoAutomation}
  virtual tBool __stdcall UpdateRaw(tPtr apData, tSize aSize) = 0;

  //! Ends the calculation of the current digest, return the digest as a string.
  //! \remark After final is called new calls to Update can be made to
  //!         compute a new hash.
  virtual cString __stdcall FinalString(eRawToStringEncoding aEncoding) = 0;
  //! Ends the calculation of the current digest, put the digest in the specified file.
  //! \remark After final is called new calls to Update can be made to
  //!         compute a new hash.
  virtual tSize __stdcall FinalFile(iFile* apOutput) = 0;
  //! Ends the calculation of the current digest, put the digest in the specified
  //! raw memory.
  //! \remark After final is called new calls to Update can be made to
  //!         compute a new hash.
  virtual tSize __stdcall FinalRaw(tPtr apData, tSize anSize) = 0;
};

/**@}*/
}

niExportFunc(ni::iUnknown*) New_niLang_CryptoHash(const ni::Var&,const ni::Var&);

/// EOF //////////////////////////////////////////////////////////////////////////////////////
#endif // #if niMinFeatures(15)
#endif // __ICRYPTO_H_05BFBCD8_3E83_4730_840C_B7BEC964EA6A__
