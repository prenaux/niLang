//
//
// cd $WORK/niLang && . hat
// # Run all the tests
// ham Run_Test_niScript_tu_linter
// # Run the tests matching the specified regex with lint tracing for that test
// ham Run_Test_niScript_tu_linter A0=-Dtest=linter_4 A1=-DlintTrace=1
//
// # Lint scripts/lang.ni
// ni -c "$WORK/niLang/scripts/lang.ni"
//
::Import("unittest.ni")
::Import("lang.ni")
::REGEX <- ::ImportModule("regex.ni")

testLinter <- {
  mTestFilter = null
  mLogs = []
  mLogsError = 0
  mLogsWarning = 0
  mFailedChecks = []
  mSucceededChecks = []
  mInLogSink = 0

  function GetThreadID() {
    return ::GetMainThreadID();
  }
  function HandleMessage(aMsg,aA,aB) {
    if (aMsg != ::eSystemMessage.Log)
      return;
    if (mInLogSink)
      return;
    mInLogSink = true
    try {
      local logType = aA
      local msg = aB
      if (msg.startswith("Lint:")) {
        if (msg.startswith("Lint: Error:")) {
          mLogsError++;
        }
        else if (msg.startswith("Lint: Warning:")) {
          mLogsWarning++;
        }
        mLogs.push(msg)
      }
    }
    catch (e) {
    }
    mInLogSink = false
  }

  function register() {
    mLogs = []
    mLogsError = 0
    mLogsWarning = 0
    ::gLang.system_message_handlers.AddSink(this)
  }

  function unregister() {
    ::gLang.system_message_handlers.RemoveSink(this)
  }

  function check(aName,afnTest) {
    if (mTestFilter && !mTestFilter.DoesMatch(aName)) {
      ::log("FILTER SKIPPED TEST:" aName)
      return
    }
    else {
      ::log("TEST:" aName)
    }

    register()
    local exc
    try {
      {
        local lintTrace = ::lang.getProperty("lintTrace")
        ::log("lintTrace:" lintTrace)
        if (lintTrace) {
          ::gLang.property["niScript.LintTrace"] = lintTrace;
        }
      }
      // This has for side effect to lint the file for now.
      // TODO: Move that in a cleaner more explicit API.
      ::Import(aName)
      ::EXPECT_LINT_OK(mLogs);
      afnTest.call(::getroottable(),mLogs,this)
    }
    catch (e) {
      mFailedChecks.push(aName)
      exc = e
      ::logError(::format("FAILED: %s, %d log(s)", aName, mLogs.size()));
    }
    if (!exc) {
      mSucceededChecks.push(aName)
      ::log(::format("SUCCEEDED: %s, %d log(s)", aName, mLogs.size()));
    }
    ::gLang.property["niScript.LintTrace"] = "0"
    unregister()
  }
}

// Takes `aLogs` explicitly so that it shows in a more readable manner in the
// failure stack.
function ::EXPECTED_LINT(aLogs,aExpectedCount,aMsg) {
  local pattern = ::REGEX.pcre(aMsg)
  local found = 0;
  foreach (l in aLogs) {
    if (pattern.DoesMatch(l))
      ++found
  }
  ::CHECK_EQUAL(aExpectedCount,found,"Expected lint: '" + aMsg + "'")
}

function ::EXPECT_LINT_OK(aLogs) {
  ::EXPECTED_LINT(aLogs, 0, "Lint: Error: internal_");
  ::EXPECTED_LINT(aLogs, 0, "Lint: Warning: internal_");
}

function main() {
  local testProperty = ::lang.getProperty("test")
  if (testProperty) {
    testLinter.mTestFilter = ::REGEX.pcre(testProperty)
  }

  testLinter.check(
    "linter_01.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);
      ::CHECK_EQUAL(13,aLintResults.mLogsError,
                    "Expected lint errors.");
      ::CHECK_EQUAL(8,aLintResults.mLogsWarning,
                    "Expected lint warnings.");
    })

  testLinter.check(
    "linter_02_this_and_roottable.ni",
    function(aLogs) {
      ::CHECK_EQUAL(1,aLogs.size(),"Lints count.");
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: Experimental: key_notfound_callk: "functionNotInRoot"]})
    })

  testLinter.check(
    "linter_03_this_set_key_notfound.ni",
    function(aLogs) {
      ::CHECK_EQUAL(1,aLogs.size(),"Lints count.");
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: this_set_key_notfound: "_unknownkey"]})
    })

  testLinter.check(
    "linter_04_function_call.ni",
    function(aLogs) {
      EXPECTED_LINT(
        aLogs, 5,
        {[call_num_args: call_func: Incorrect number of arguments passed]})
      EXPECTED_LINT(
        aLogs, 1,
        {[call_num_args: call_func: Incorrect number of arguments passed, expected 0 but got 1. Calling f0]})
      EXPECTED_LINT(
        aLogs, 1,
        {[call_num_args: call_func: Incorrect number of arguments passed, expected 0 but got 2. Calling f0]})
      EXPECTED_LINT(
        aLogs, 1,
        {[call_num_args: call_func: Incorrect number of arguments passed, expected 3 but got 4. Calling f3]})
      EXPECTED_LINT(
        aLogs, 1,
        {[call_num_args: call_func: Incorrect number of arguments passed, expected 3 but got 2. Calling f3]})

      ::CHECK_EQUAL(5,aLogs.size(),"Lints count.");
    })

  testLinter.check(
    "linter_05_method_def_call.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);

      EXPECTED_LINT(
        aLogs, 1,
        {[call_num_args: call_method: Incorrect number of arguments passed, expected 2 but got 3. Calling method_def<iMath,RandIntRange/2>.]});

      EXPECTED_LINT(
        aLogs, 1,
        {[call_num_args: call_method: Incorrect number of arguments passed, expected 2 but got 1. Calling method_def<iMath,RandIntRange/2>.]});

      EXPECTED_LINT(
        aLogs, 1,
        {[call_num_args: call_method: Incorrect number of arguments passed, expected 1 but got 0. Calling method_def<iFile,WriteString/1>.]});

      ::CHECK_EQUAL(4,aLintResults.mLogsError,
                    "Expected lint errors.");
      ::CHECK_EQUAL(1,aLintResults.mLogsWarning,
                    "Expected lint warnings.");
    })

  testLinter.check(
    "linter_06_query_interface.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);

      EXPECTED_LINT(
        aLogs, 1,
        "call_null: Attempting to call 'error_code<error_code_cant_find_method_def,method_def<iUnknown::RandIntRange>>");

      EXPECTED_LINT(
        aLogs, 1,
        {[key_notfound_callk: "RandIntRange" not found in interface_def<iUnknown>]});

      ::CHECK_EQUAL(1,aLintResults.mLogsError,
                    "Expected lint errors.");
      ::CHECK_EQUAL(1,aLintResults.mLogsWarning,
                    "Expected lint warnings.");
    })

  testLinter.check(
    "linter_07_call_native_func.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);

      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_num_args: call_method: Incorrect number of arguments passed, expected 1 but got 2. Calling method_def<NULL,vmprintln/1>.");

      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_error: call_lint_func: CreateInstance/-1: too many arguments '4', expected at most 3.");
      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_error: call_lint_func: CreateInstance/-1: not enough arguments '0', expected at least 1.");

      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_error: call_lint_func: CreateGlobalInstance/-1: too many arguments '4', expected at most 3.");
      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_error: call_lint_func: CreateGlobalInstance/-1: not enough arguments '0', expected at least 1.");

      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_error: call_lint_func: CreateGlobalInstance/-1: Cant find object type 'niLang.TheUnknownHamster'.");

      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_num_args: call_nativeclosure: Incorrect number of arguments, expected 1 but got 2. Calling endswith/1.");
      EXPECTED_LINT(
        aLogs, 1,
        "Lint: Error: call_num_args: call_nativeclosure: Incorrect number of arguments, expected at least 1 but got 0. Calling find/-3.");

      ::CHECK_EQUAL(8,aLintResults.mLogsError,
                    "Expected lint errors.");
      ::CHECK_EQUAL(0,aLintResults.mLogsWarning,
                    "Expected lint warnings.");
    })

  testLinter.check(
    "linter_08_lint_assert_type.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);

      EXPECTED_LINT(
        aLogs, 1,
        {[key_notfound_callk: "Log" not found in interface_def<iUnknown>]});

      ::CHECK_EQUAL(1,aLintResults.mLogsError,
                    "Expected lint errors.");
      ::CHECK_EQUAL(1,aLintResults.mLogsWarning,
                    "Expected lint warnings.");
    })

  testLinter.check(
    "linter_09_builtin_delegates.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);

      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<int>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<float>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<string>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<array>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<table>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<closure>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<Vec2>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<Vec3>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<Vec4>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<Matrix>]});
      EXPECTED_LINT(aLogs, 1,
                    {[key_notfound_callk: "thehamster" not found in resolved_type<UUID>]});

      EXPECTED_LINT(
        aLogs, 11,
        {[key_notfound_callk: "thehamster" not found in resolved_type]});

      ::CHECK_EQUAL(11, aLintResults.mLogsError, "Expected lint errors.");
      ::CHECK_EQUAL(11, aLintResults.mLogsWarning, "Expected lint warnings.");
    })

  testLinter.check(
    "linter_10_function_ret_type.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);

      EXPECTED_LINT(aLogs, 1,
                    "ret_type_cant_assign: Cant assign type 'int' to return type 'string'");

      EXPECTED_LINT(aLogs, 1,
                    "ret_type_cant_assign: Cant assign type 'string' to return type 'int'");

      ::CHECK_EQUAL(2, aLintResults.mLogsError, "Expected lint errors.");
      ::CHECK_EQUAL(0, aLintResults.mLogsWarning, "Expected lint warnings.");
    })

  // Output failed tests
  if (!testLinter.mFailedChecks.empty()) {
    ::logError(::format("Linter test failed: %d",
                        testLinter.mFailedChecks.size()));
    foreach (n in testLinter.mFailedChecks) {
      ::println("- " + n);
    }
    ::gLang.Exit(1)
  }
  else {
    ::log(::format("All linter tests succeed: %d",
                   testLinter.mSucceededChecks.size()));
  }
}
