//
//
// cd $WORK/niLang && . hat
// # Run all the tests
// ham Run_Test_niScript_tu_linter
// # Run the tests matching the specified regex with lint tracing for that test
// ham Run_Test_niScript_tu_linter A0=-Dtest=linter_4 A1=-DlintTrace=1
// # Also dump the function's general compilation info with -DlintDump=1
// ham Run_Test_niScript_tu_linter A0=-Dtest=linter_4 A1=-DlintTrace=1 A2=-DlintDump=1
//
//
::Import("unittest.ni")
::Import("lang.ni")
::REGEX <- ::ImportModule("regex.ni")

testLinter <- {
  mTestFilter = null
  mLogs = []
  mLogsError = 0
  mLogsWarning = 0
  mFailedChecks = []
  mSucceededChecks = []
  mInLogSink = 0

  function GetThreadID() {
    return ::GetMainThreadID();
  }
  function HandleMessage(aMsg,aA,aB) {
    if (aMsg != ::eSystemMessage.Log)
      return;
    if (mInLogSink)
      return;
    mInLogSink = true
    try {
      local logType = aA
      local msg = aB
      if (msg.startswith("Lint:")) {
        if (msg.startswith("Lint: Error:")) {
          mLogsError++;
        }
        else if (msg.startswith("Lint: Warning:")) {
          mLogsWarning++;
        }
        mLogs.push(msg)
      }
    }
    catch (e) {
    }
    mInLogSink = false
  }

  function register() {
    mLogs = []
    mLogsError = 0
    mLogsWarning = 0
    ::gLang.system_message_handlers.AddSink(this)
  }

  function unregister() {
    ::gLang.system_message_handlers.RemoveSink(this)
  }

  function check(aName,afnTest) {
    if (mTestFilter && !mTestFilter.DoesMatch(aName)) {
      ::log("FILTER SKIPPED TEST:" aName)
      return
    }
    else {
      ::log("TEST:" aName)
    }

    register()
    local exc
    try {
      {
        local lintTrace = ::lang.getProperty("lintTrace")
        ::log("lintTrace:" lintTrace)
        if (lintTrace) {
          ::gLang.property["niScript.LintTrace"] = lintTrace;
        }
      }
      {
        local lintDump = ::lang.getProperty("lintDump")
        ::log("lintDump:" lintDump)
        if (lintDump) {
          ::gLang.property["niScript.LintDump"] = lintDump;
        }
      }
      // This has for side effect to lint the file for now.
      // TODO: Move that in a cleaner more explicit API.
      ::Import(aName)
      ::EXPECT_LINT_OK(mLogs);
      afnTest.call(::getroottable(),mLogs,this)
    }
    catch (e) {
      mFailedChecks.push(aName)
      exc = e
      ::logError(::format("FAILED: %s, %d log(s)", aName, mLogs.size()));
    }
    if (!exc) {
      mSucceededChecks.push(aName)
      ::log(::format("SUCCEEDED: %s, %d log(s)", aName, mLogs.size()));
    }
    ::gLang.property["niScript.LintTrace"] = "0"
    ::gLang.property["niScript.LintDump"] = "0"
    unregister()
  }
}

// Takes `aLogs` explicitly so that it shows in a more readable manner in the
// failure stack.
function ::EXPECTED_LINT(aLogs,aExpectedCount,aMsg) {
  local pattern = ::REGEX.pcre(aMsg)
  local found = 0;
  foreach (l in aLogs) {
    if (pattern.DoesMatch(l))
      ++found
  }
  ::CHECK_EQUAL(aExpectedCount,found,"Expected lint: '" + aMsg + "'")
}

function ::EXPECT_LINT_OK(aLogs) {
  ::EXPECTED_LINT(aLogs, 0, "Lint: Error: internal_");
  ::EXPECTED_LINT(aLogs, 0, "Lint: Warning: internal_");
}

function main() {
  local testProperty = ::lang.getProperty("test")
  if (testProperty) {
    testLinter.mTestFilter = ::REGEX.pcre(testProperty)
  }

  testLinter.check(
    "linter_1.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);
      ::CHECK_EQUAL(13,aLintResults.mLogsError,
                    "Expected lint errors.");
      ::CHECK_EQUAL(8,aLintResults.mLogsWarning,
                    "Expected lint warnings.");
    })

  testLinter.check(
    "linter_2_this_and_roottable.ni",
    function(aLogs) {
      ::CHECK_EQUAL(1,aLogs.size(),"Lints count.");
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: Experimental: key_notfound_callk: "functionNotInRoot"]})
    })

  testLinter.check(
    "linter_3_this_set_key_notfound.ni",
    function(aLogs) {
      ::CHECK_EQUAL(1,aLogs.size(),"Lints count.");
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: this_set_key_notfound: "_unknownkey"]})
    })

  testLinter.check(
    "linter_4_function_call.ni",
    function(aLogs) {
      ::CHECK_EQUAL(6,aLogs.size(),"Lints count.");
      EXPECTED_LINT(
        aLogs, 5,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed]})
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed, expected 0 but got 1. Calling f0]})
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed, expected 0 but got 2. Calling f0]})
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed, expected 3 but got 4. Calling f3]})
      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed, expected 3 but got 2. Calling f3]})
    })

  testLinter.check(
    "linter_5_method_def_call.ni",
    function(aLogs,aLintResults) {
      ::EXPECT_LINT_OK(aLogs);
      ::CHECK_EQUAL(4,aLintResults.mLogsError,
                    "Expected lint errors.");
      ::CHECK_EQUAL(1,aLintResults.mLogsWarning,
                    "Expected lint warnings.");

      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed, expected 2 but got 3. Calling method_def<iMath,RandIntRange/2>.]});

      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed, expected 2 but got 1. Calling method_def<iMath,RandIntRange/2>.]});

      EXPECTED_LINT(
        aLogs, 1,
        {[Lint: Error: call_num_args: Incorrect number of arguments passed, expected 1 but got 0. Calling method_def<iFile,WriteString/1>.]});
    })

  // Output failed tests
  if (!testLinter.mFailedChecks.empty()) {
    ::logError(::format("Linter test failed: %d",
                        testLinter.mFailedChecks.size()));
    foreach (n in testLinter.mFailedChecks) {
      ::println("- " + n);
    }
    ::gLang.Exit(1)
  }
  else {
    ::log(::format("All linter tests succeed: %d",
                   testLinter.mSucceededChecks.size()));
  }
}
